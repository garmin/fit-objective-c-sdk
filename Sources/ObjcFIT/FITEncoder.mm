/////////////////////////////////////////////////////////////////////////////////////////////
// Copyright 2024 Garmin International, Inc.
// Licensed under the Flexible and Interoperable Data Transfer (FIT) Protocol License; you
// may not use this file except in compliance with the Flexible and Interoperable Data
// Transfer (FIT) Protocol License.
/////////////////////////////////////////////////////////////////////////////////////////////
// ****WARNING****  This file is auto-generated!  Do NOT edit this file.
// Profile Version = 21.158.0Release
// Tag = production/release/21.158.0-0-gc9428aa
/////////////////////////////////////////////////////////////////////////////////////////////


#import <fstream>
#import <fit_encode.hpp>

#import "FITEncoder.h"

#import "FITMessage+Internal.h"

@interface FITEncoder ()
@property (nonatomic, readwrite, assign) fit::Encode *encoder;
@property (nonatomic, readwrite, assign) std::fstream *file;
@end

@implementation FITEncoder

-(instancetype)initWithVersion:(FITProtocolVersion)version {
    self = [super init];
    if (self) {
        _encoder = new fit::Encode(version == FITProtocolVersionV20 ? fit::ProtocolVersion::V20 : fit::ProtocolVersion::V10 );
    }
    return self;
}

-(void)dealloc {
    delete _encoder;
    _encoder = nullptr;

    [self closeFile];
}

-(BOOL)open:(NSString *)filename {
    _file = new std::fstream();
    _file->open(filename.UTF8String, std::ios::in | std::ios::out | std::ios::binary | std::ios::trunc);

    if(!_file->is_open()) {
        return NO;
    }

    _encoder->Open(*_file);

    return YES;
}


-(void)writeMessage:(FITMessage *)message {
    fit::Mesg *mesg = [message getInternalFitMesg];
    _encoder->Write(*mesg);
}

- (void)writeMessages:(NSArray<FITMessage *>*)mesgs {
    for (id mesg in mesgs) {
        [self writeMessage:mesg];
    }
}

-(BOOL)close {
    FIT_BOOL retval = _encoder->Close();

    [self closeFile];

    return retval == FIT_TRUE ? YES : NO;
}

-(void)closeFile {
    if (_file != nullptr) {
        if (_file->is_open()) {
            _file->close();
        }

        delete _file;
        _file = nullptr;
    }
}

@end
